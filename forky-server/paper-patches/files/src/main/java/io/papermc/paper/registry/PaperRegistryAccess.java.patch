--- a/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
@@ -1,7 +_,7 @@
 package io.papermc.paper.registry;
 
+import io.papermc.paper.registry.entry.ApiRegistryEntry;
 import io.papermc.paper.registry.entry.RegistryEntry;
-import io.papermc.paper.registry.entry.RegistryEntryMeta;
 import io.papermc.paper.registry.legacy.DelayedRegistry;
 import io.papermc.paper.registry.legacy.DelayedRegistryEntry;
 import io.papermc.paper.registry.legacy.LegacyRegistryIdentifiers;
@@ -13,7 +_,6 @@
 import net.minecraft.resources.ResourceKey;
 import org.bukkit.Keyed;
 import org.bukkit.Registry;
-import org.bukkit.craftbukkit.CraftRegistry;
 import org.jetbrains.annotations.VisibleForTesting;
 import org.jspecify.annotations.Nullable;
 
@@ -32,10 +_,7 @@
 
     @VisibleForTesting
     public Set<RegistryKey<?>> getLoadedServerBackedRegistries() {
-        return this.registries.keySet().stream().filter(registryHolder -> {
-            final RegistryEntry<?, ?> entry = PaperRegistries.getEntry(registryHolder);
-            return entry != null && !(entry.meta() instanceof RegistryEntryMeta.ApiOnly<?,?>);
-        }).collect(Collectors.toUnmodifiableSet());
+        return this.registries.keySet().stream().filter(registryHolder -> !(PaperRegistries.getEntry(registryHolder) instanceof ApiRegistryEntry)).collect(Collectors.toUnmodifiableSet());
     }
 
     @SuppressWarnings("unchecked")
@@ -73,7 +_,7 @@
         if (PaperRegistries.getEntry(key) == null) {
             throw new NoSuchElementException(key + " is not a valid registry key");
         }
-        final RegistryHolder<T> registryHolder = (RegistryHolder<T>) this.registries.get(key);
+        final @Nullable RegistryHolder<T> registryHolder = (RegistryHolder<T>) this.registries.get(key);
         if (registryHolder == null) {
             throw new IllegalArgumentException(key + " points to a registry that is not available yet");
         }
@@ -105,22 +_,13 @@
         this.registerRegistry(resourceKey, registry, false);
     }
 
-    public <M> void lockReferenceHolders(final ResourceKey<? extends net.minecraft.core.Registry<M>> resourceKey) {
-        final RegistryEntry<M, Keyed> entry = PaperRegistries.getEntry(resourceKey);
-        if (entry == null || !(entry.meta() instanceof final RegistryEntryMeta.ServerSide<M, Keyed> serverSide) || !serverSide.registryTypeMapper().constructorUsesHolder()) {
-            return;
-        }
-        final CraftRegistry<?, M> registry = (CraftRegistry<?, M>) this.getRegistry(entry.apiKey());
-        registry.lockReferenceHolders();
-    }
-
     @SuppressWarnings("unchecked") // this method should be called right after any new MappedRegistry instances are created to later be used by the server.
     private <M, B extends Keyed, R extends Registry<B>> void registerRegistry(final ResourceKey<? extends net.minecraft.core.Registry<M>> resourceKey, final net.minecraft.core.Registry<M> registry, final boolean replace) {
-        final RegistryEntry<M, B> entry = PaperRegistries.getEntry(resourceKey);
+        final @Nullable RegistryEntry<M, B> entry = PaperRegistries.getEntry(resourceKey);
         if (entry == null) { // skip registries that don't have API entries
             return;
         }
-        final RegistryHolder<B> registryHolder = (RegistryHolder<B>) this.registries.get(entry.apiKey());
+        final @Nullable RegistryHolder<B> registryHolder = (RegistryHolder<B>) this.registries.get(entry.apiKey());
         if (registryHolder == null || replace) {
             // if the holder doesn't exist yet, or is marked as "replaceable", put it in the map.
             this.registries.put(entry.apiKey(), entry.createRegistryHolder(registry));
