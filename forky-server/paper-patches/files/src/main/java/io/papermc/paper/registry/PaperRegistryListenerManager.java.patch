--- a/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
@@ -9,7 +_,7 @@
 import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
 import io.papermc.paper.registry.data.util.Conversions;
 import io.papermc.paper.registry.entry.RegistryEntry;
-import io.papermc.paper.registry.entry.RegistryEntryMeta;
+import io.papermc.paper.registry.entry.RegistryEntryInfo;
 import io.papermc.paper.registry.event.RegistryEntryAddEventImpl;
 import io.papermc.paper.registry.event.RegistryEventMap;
 import io.papermc.paper.registry.event.RegistryEventProvider;
@@ -28,7 +_,6 @@
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import org.bukkit.Keyed;
 import org.intellij.lang.annotations.Subst;
 import org.jspecify.annotations.Nullable;
 
@@ -87,7 +_,8 @@
         this.registerWithListeners(registry, key, nms, registrationInfo, WritableRegistry::register, conversions);
     }
 
-    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners( // TODO remove Keyed
+    // TODO remove Keyed
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners(
         final Registry<M> registry,
         final ResourceKey<M> key,
         final M nms,
@@ -96,33 +_,34 @@
         final Conversions conversions
     ) {
         Preconditions.checkState(LaunchEntryPointHandler.INSTANCE.hasEntered(Entrypoint.BOOTSTRAPPER), registry.key() + " tried to run modification listeners before bootstrappers have been called"); // verify that bootstrappers have been called
-        final RegistryEntry<M, T> entry = PaperRegistries.getEntry(registry.key());
-        if (entry == null || !entry.meta().modificationApiSupport().canModify() || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
+        final RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(registry.key());
+        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
             return registerMethod.register((WritableRegistry<M>) registry, key, nms, registrationInfo);
         }
-        final RegistryEntryMeta.Buildable<M, T, B> modifiableEntry = (RegistryEntryMeta.Buildable<M, T, B>) entry.meta();
-        final B builder = modifiableEntry.builderFiller().fill(conversions, nms);
+        final RegistryEntry.Modifiable<M, T, B> modifiableEntry = RegistryEntry.Modifiable.asModifiable(entry);
+        @SuppressWarnings("PatternValidation") final TypedKey<T> typedKey = TypedKey.create(entry.apiKey(), Key.key(key.location().getNamespace(), key.location().getPath()));
+        final B builder = modifiableEntry.fillBuilder(conversions, nms);
         return this.registerWithListeners(registry, modifiableEntry, key, nms, builder, registrationInfo, registerMethod, conversions);
     }
 
-    <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> void registerWithListeners( // TODO remove Keyed
+    <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void registerWithListeners( // TODO remove Keyed
         final WritableRegistry<M> registry,
-        final RegistryEntryMeta.Buildable<M, T, B> entry,
+        final RegistryEntryInfo<M, T> entry,
         final ResourceKey<M> key,
         final B builder,
         final RegistrationInfo registrationInfo,
         final Conversions conversions
     ) {
-        if (!entry.modificationApiSupport().canModify() || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
+        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
             registry.register(key, builder.build(), registrationInfo);
             return;
         }
-        this.registerWithListeners(registry, entry, key, null, builder, registrationInfo, WritableRegistry::register, conversions);
+        this.registerWithListeners(registry, RegistryEntry.Modifiable.asModifiable(entry), key, null, builder, registrationInfo, WritableRegistry::register, conversions);
     }
 
-    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners( // TODO remove Keyed
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners( // TODO remove Keyed
         final Registry<M> registry,
-        final RegistryEntryMeta.Buildable<M, T, B> entry,
+        final RegistryEntry.Modifiable<M, T, B> entry,
         final ResourceKey<M> key,
         final @Nullable M oldNms,
         final B builder,
@@ -155,28 +_,26 @@
         R register(WritableRegistry<M> writableRegistry, ResourceKey<M> key, M value, RegistrationInfo registrationInfo);
     }
 
-    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> void runFreezeListeners(final ResourceKey<? extends Registry<M>> resourceKey, final Conversions conversions) {
-        final RegistryEntry<M, T> entry = PaperRegistries.getEntry(resourceKey);
-        if (entry == null || !entry.meta().modificationApiSupport().canAdd() || !this.freezeEventTypes.hasHandlers(entry.apiKey())) {
+    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void runFreezeListeners(final ResourceKey<? extends Registry<M>> resourceKey, final Conversions conversions) {
+        final RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(resourceKey);
+        if (!RegistryEntry.Addable.isAddable(entry) || !this.freezeEventTypes.hasHandlers(entry.apiKey())) {
             return;
         }
-        final RegistryEntryMeta.Buildable<M, T, B> writableEntry = (RegistryEntryMeta.Buildable<M, T, B>) entry.meta();
+        final RegistryEntry.Addable<M, T, B> writableEntry = RegistryEntry.Addable.asAddable(entry);
         final WritableCraftRegistry<M, T, B> writableRegistry = PaperRegistryAccess.instance().getWritableRegistry(entry.apiKey());
         final RegistryFreezeEventImpl<T, B> event = writableEntry.createFreezeEvent(writableRegistry, conversions);
         LifecycleEventRunner.INSTANCE.callEvent(this.freezeEventTypes.getEventType(entry.apiKey()), event);
     }
 
     public <T, B extends RegistryBuilder<T>> RegistryEntryAddEventType<T, B> getRegistryValueAddEventType(final RegistryEventProvider<T, B> type) {
-        final RegistryEntry<?, ?> entry = PaperRegistries.getEntry(type.registryKey());
-        if (entry == null || !entry.meta().modificationApiSupport().canModify()) {
+        if (!RegistryEntry.Modifiable.isModifiable(PaperRegistries.getEntry(type.registryKey()))) {
             throw new IllegalArgumentException(type.registryKey() + " does not support RegistryEntryAddEvent");
         }
         return this.valueAddEventTypes.getOrCreate(type.registryKey(), RegistryEntryAddEventTypeImpl::new);
     }
 
     public <T, B extends RegistryBuilder<T>> LifecycleEventType.Prioritizable<BootstrapContext, RegistryFreezeEvent<T, B>> getRegistryFreezeEventType(final RegistryEventProvider<T, B> type) {
-        final RegistryEntry<?, ?> entry = PaperRegistries.getEntry(type.registryKey());
-        if (entry == null || !entry.meta().modificationApiSupport().canAdd()) {
+        if (!RegistryEntry.Addable.isAddable(PaperRegistries.getEntry(type.registryKey()))) {
             throw new IllegalArgumentException(type.registryKey() + " does not support RegistryFreezeEvent");
         }
         return this.freezeEventTypes.getOrCreate(type.registryKey(), RegistryLifecycleEventType::new);
