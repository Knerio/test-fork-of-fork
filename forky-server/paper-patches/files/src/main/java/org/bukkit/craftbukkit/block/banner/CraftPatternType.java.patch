--- a/src/main/java/org/bukkit/craftbukkit/block/banner/CraftPatternType.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/banner/CraftPatternType.java
@@ -1,22 +_,26 @@
 package org.bukkit.craftbukkit.block.banner;
 
-import io.papermc.paper.util.OldEnumHolderable;
+import com.google.common.base.Preconditions;
+import java.util.Locale;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.level.block.entity.BannerPattern;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Registry;
 import org.bukkit.block.banner.PatternType;
 import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.Handleable;
 
-public class CraftPatternType extends OldEnumHolderable<PatternType, BannerPattern> implements PatternType {
+public class CraftPatternType implements PatternType, Handleable<BannerPattern> {
 
     private static int count = 0;
 
     public static PatternType minecraftToBukkit(BannerPattern minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BANNER_PATTERN);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BANNER_PATTERN, Registry.BANNER_PATTERN);
     }
 
     public static PatternType minecraftHolderToBukkit(Holder<BannerPattern> minecraft) {
-        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registries.BANNER_PATTERN);
+        return CraftPatternType.minecraftToBukkit(minecraft.value());
     }
 
     public static BannerPattern bukkitToMinecraft(PatternType bukkit) {
@@ -24,11 +_,86 @@
     }
 
     public static Holder<BannerPattern> bukkitToMinecraftHolder(PatternType bukkit) {
-        return CraftRegistry.bukkitToMinecraftHolder(bukkit, Registries.BANNER_PATTERN);
-    }
-
-    public CraftPatternType(Holder<BannerPattern> bannerPatternType) {
-       super(bannerPatternType, count++);
+        Preconditions.checkArgument(bukkit != null);
+
+        net.minecraft.core.Registry<BannerPattern> registry = CraftRegistry.getMinecraftRegistry(Registries.BANNER_PATTERN);
+
+        if (registry.wrapAsHolder(CraftPatternType.bukkitToMinecraft(bukkit)) instanceof Holder.Reference<BannerPattern> holder) {
+            return holder;
+        }
+
+        throw new IllegalArgumentException("No Reference holder found for " + bukkit
+                + ", this can happen if a plugin creates its own banner pattern without properly registering it.");
+    }
+
+    private final NamespacedKey key;
+    private final BannerPattern bannerPatternType;
+    private final String name;
+    private final int ordinal;
+
+    public CraftPatternType(NamespacedKey key, BannerPattern bannerPatternType) {
+        this.key = key;
+        this.bannerPatternType = bannerPatternType;
+        // For backwards compatibility, minecraft values will stile return the uppercase name without the namespace,
+        // in case plugins use for example the name as key in a config file to receive pattern type specific values.
+        // Custom pattern types will return the key with namespace. For a plugin this should look than like a new pattern type
+        // (which can always be added in new minecraft versions and the plugin should therefore handle it accordingly).
+        if (NamespacedKey.MINECRAFT.equals(key.getNamespace())) {
+            this.name = key.getKey().toUpperCase(Locale.ROOT);
+        } else {
+            this.name = key.toString();
+        }
+        this.ordinal = CraftPatternType.count++;
+    }
+
+    @Override
+    public BannerPattern getHandle() {
+        return this.bannerPatternType;
+    }
+
+    @Override
+    public NamespacedKey getKey() {
+        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.BANNER_PATTERN.getKey(this), () -> this + " doesn't have a key"); // Paper
+        return this.key;
+    }
+
+    @Override
+    public int compareTo(PatternType patternType) {
+        return this.ordinal - patternType.ordinal();
+    }
+
+    @Override
+    public String name() {
+        return this.name;
+    }
+
+    @Override
+    public int ordinal() {
+        return this.ordinal;
+    }
+
+    @Override
+    public String toString() {
+        // For backwards compatibility
+        return this.name();
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+
+        if (!(other instanceof CraftPatternType)) {
+            return false;
+        }
+
+        return this.getKey().equals(((PatternType) other).getKey());
+    }
+
+    @Override
+    public int hashCode() {
+        return this.getKey().hashCode();
     }
 
     @Override
